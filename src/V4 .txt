#include <Arduino.h>
#include "TFT_eSPI.h"
#include "Tulip Landscape 480x320.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/semphr.h"
#include <vector>
#include "Untitled-5.h"
#include "Home Menu 1 .h"
#include "Home Menu 2 .h"

#define BL 4
#define SCREEN_W 320
#define SCREEN_H 480

#define TILE_W (SCREEN_W / 4)
#define TILE_H (SCREEN_H /  2)

const int NUM_COLS = SCREEN_W / TILE_W;
const int NUM_ROWS = SCREEN_H / TILE_H;

#define NUM_SECTIONS 4

struct TextItem {
  String text;
  int x;
  int y;
};

struct BoxItem {
  int x, y, w, h,r;
  uint16_t color;
};
struct CircleItem {
  int x, y, r;
  uint16_t color;
};
struct BorderItem {
  int x, y, w, h, r;
  uint16_t color;
  uint8_t thickness;
};

std::vector<BorderItem> borderQueue;
std::vector<TextItem> textQueue;
std::vector<BoxItem> boxQueue;
std::vector<CircleItem> CircleQueue;

const uint16_t *currentBackground = nullptr;

TFT_eSPI tft = TFT_eSPI();

TFT_eSprite sprites[NUM_SECTIONS] = {
  TFT_eSprite(&tft),
  TFT_eSprite(&tft),
  TFT_eSprite(&tft),
  TFT_eSprite(&tft)
};

TaskHandle_t tileTaskHandles[NUM_SECTIONS];
SemaphoreHandle_t renderCompleteSemaphore;
SemaphoreHandle_t tftMutex;

float fps = 0.0;

struct TileTaskData {
  int sectionId;
  int startCol;
  int endCol;
};

TileTaskData taskData[NUM_SECTIONS];

// === Utility ===
uint16_t getTileColor(int tileX, int tileY) {
  uint8_t r = (tileX * 70) % 256;
  uint8_t g = (tileY * 120) % 256;
  uint8_t b = (tileX * tileY * 45) % 256;
  return tft.color565(r, g, b);
}

uint16_t hexTo565(uint32_t hexColor) {
  uint8_t r = (hexColor >> 16) & 0xFF;
  uint8_t g = (hexColor >> 8) & 0xFF;
  uint8_t b = hexColor & 0xFF;

  return tft.color565(r, g, b);
}



void drawBackground(const uint16_t *image) {
  currentBackground = image;
}

void drawText(String text, int x, int y) {
  textQueue.push_back({text, x, y});
}

void drawBox(int x, int y, int w, int h,int r, uint16_t color) {
  boxQueue.push_back({x, y, w, h,r, color});
}
void drawCircle(int x, int y, int r, uint16_t color) {
  CircleQueue.push_back({x, y, r, color});
}
void drawBorder(int x, int y, int w, int h, int r, uint16_t color, uint8_t thickness = 1) {
  borderQueue.push_back({x, y, w, h, r, color, thickness});
}


void sendGraphics(int id, int baseX, int baseY) {
  // Draw text
  sprites[id].setTextDatum(MC_DATUM);
  sprites[id].setFreeFont(&FreeSansBoldOblique24pt7b);
  sprites[id].setTextColor(TFT_WHITE);

  for (auto &item : textQueue) {
    sprites[id].drawString(item.text, baseX + item.x, baseY + item.y);
  }

  // Draw boxes
  for (auto &box : boxQueue) {
    sprites[id].fillRoundRect(baseX + box.x, baseY + box.y, box.w, box.h, box.r, box.color);
  }

    for (auto &circle : CircleQueue) {
    sprites[id].fillCircle(baseX + circle.x, baseY + circle.y, circle.r, circle.color);
  }
  // Draw borders
// Draw borders with fixed rounded corner gaps
for (auto &border : borderQueue) {
  for (int i = 0; i < border.thickness; ++i) {
    int shrink = i;
    int radius = max(border.r - i, 0);  // Ensure radius doesn't go negative

    sprites[id].drawRoundRect(
      baseX + border.x + shrink,
      baseY + border.y + shrink,
      border.w - 2 * shrink,
      border.h - 2 * shrink,
      radius,
      border.color
    );
  }
}


}

// === Parallel Tile Rendering Task (Vertical) ===
void tileRenderTask(void *parameter) {
  TileTaskData *data = (TileTaskData *)parameter;
  int sectionId = data->sectionId;

  sprites[sectionId].setColorDepth(16);
  sprites[sectionId].createSprite(TILE_W, TILE_H);

  while (true) {
    ulTaskNotifyTake(pdTRUE, portMAX_DELAY);

    for (int tx = data->startCol; tx < data->endCol; tx++) {
      for (int ty = 0; ty < NUM_ROWS; ty++) {
        int screenX = tx * TILE_W;
        int screenY = ty * TILE_H;

        uint16_t *buf = (uint16_t *)sprites[sectionId].getPointer();

        if (currentBackground) {
          const uint16_t *src = &currentBackground[(ty * TILE_H) * SCREEN_W + (tx * TILE_W)];
          for (int y = 0; y < TILE_H; y++) {
            for (int x = 0; x < TILE_W; x++) {
              uint16_t pixel = src[y * SCREEN_W + x];
              buf[y * TILE_W + x] = (pixel >> 8) | (pixel << 8);
            }
          }
        } else {
          for (int y = 0; y < TILE_H; y++) {
            for (int x = 0; x < TILE_W; x++) {
              buf[y * TILE_W + x] = getTileColor(screenX + x, screenY + y);
            }
          }
        }

        int centerX = (SCREEN_W / 2) - screenX;
        int centerY = (SCREEN_H / 2) - screenY;
        if (abs(centerX) < SCREEN_W && abs(centerY) < SCREEN_H) {
          sendGraphics(sectionId, centerX, centerY);
        }

        if (xSemaphoreTake(tftMutex, portMAX_DELAY) == pdTRUE) {
          sprites[sectionId].pushSprite(screenX, screenY);
          xSemaphoreGive(tftMutex);
        }
      }
    }

    xSemaphoreGive(renderCompleteSemaphore);
  }
}

void drawRender() {
  for (int i = 0; i < NUM_SECTIONS; i++) {
    xTaskNotifyGive(tileTaskHandles[i]);
  }

  for (int i = 0; i < NUM_SECTIONS; i++) {
    xSemaphoreTake(renderCompleteSemaphore, portMAX_DELAY);
  }

  textQueue.clear();
  boxQueue.clear();
  CircleQueue.clear();
  borderQueue.clear();

}

void drawSetup() {
  renderCompleteSemaphore = xSemaphoreCreateCounting(NUM_SECTIONS, 0);
  tftMutex = xSemaphoreCreateMutex();

  int colsPerSection = NUM_COLS / NUM_SECTIONS;
  int remainingCols = NUM_COLS % NUM_SECTIONS;

  for (int i = 0; i < NUM_SECTIONS; i++) {
    taskData[i].sectionId = i;
    taskData[i].startCol = i * colsPerSection;
    taskData[i].endCol = (i + 1) * colsPerSection;
    if (i == NUM_SECTIONS - 1) {
      taskData[i].endCol += remainingCols;
    }

    String taskName = "TileTask" + String(i);
    xTaskCreatePinnedToCore(
      tileRenderTask,
      taskName.c_str(),
      4096,
      &taskData[i],
      1,
      &tileTaskHandles[i],
      i % 2
    );

    Serial.printf("Created %s for cols %d - %d\n",
                  taskName.c_str(), taskData[i].startCol, taskData[i].endCol - 1);
  }
}

void setup() {
  Serial.begin(115200);

  pinMode(BL, OUTPUT);
  digitalWrite(BL, HIGH);

  tft.init();
  tft.setRotation(0);
  tft.setSwapBytes(true);
  tft.fillScreen(TFT_BLACK);

  tft.setTextColor(TFT_WHITE, TFT_BLACK);
  tft.drawString("Starting vertical tile rendering...", 10, 10, 2);

  drawSetup();

  delay(500);
  Serial.println("Vertical tile rendering system initialized!");
}

//uint16_t myColor = tft.color565(120, 200, 150);


void loop() {
 // String myHex = "FCB32C"; 
uint16_t myColor = hexTo565(0xFCB32C);// or "#FCB32C"


  unsigned long frameStart = millis();

  drawBackground(image_data_HomeMenu1);
  //drawText("WORLD", 0, 40);

  // Draw a red box centered at screen
  drawBox(-40, -40, 80, 80,10, TFT_RED);
  drawBox(40, 40, 80, 80,0, TFT_BLUE);
  drawCircle(0,0,10,TFT_DARKGREEN);
  drawCircle(100,100,30,myColor);
    drawBorder(0,0,250,100,50,myColor,5);
  // Optional: display FPS text
  char fpsText[32];
  snprintf(fpsText, sizeof(fpsText), "FPS: %.4f", fps);
  drawText(fpsText, 0, -120);  // adjust as needed

  drawRender();

  unsigned long frameEnd = millis();
  unsigned long frameTime = frameEnd - frameStart;
  fps = 1000.0 / (float)frameTime;
  Serial.printf("Vertical rendering: %.4f   FPS\n", fps);

  // vTaskDelay(pdMS_TO_TICKS(50));
}
